<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAE Academy — Assembler</title>

  <link rel="icon" href="assets/mae.png">

  <style>
    :root{
      /* SAME AS CODE 1 */
      --bg:#eaf2ff;
      --bg2:#f8fbff;
      --card:#ffffff;
      --text:#09102a;
      --muted:#4c5d88;
      --brand:#08b58d;
      --brand2:#3f6fff;
      --danger:#d32f2f;
      --border: rgba(9,16,42,.14);
      --shadow: 0 22px 60px rgba(16,24,40,.12);
      --radius: 22px;

      /* SAME PAGE WIDTH (W) */
      --W: 1200px;

      /* extra */
      --good:#16a34a;
      --bad:#e11d48;
      --panel2:#f3f6ff;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Apple Gothic",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      transition: opacity 0.5s ease;
      opacity: 0;
      background:
        radial-gradient(900px 520px at 15% -10%, rgba(63,111,255,.20), transparent 55%),
        radial-gradient(900px 520px at 86% 0%, rgba(8,181,141,.18), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      overflow-x:hidden;
    }
    a{color:inherit;text-decoration:none}
    .container{width:min(var(--W),92%);margin-inline:auto}

    /* ===== HEADER (SAME AS CODE 1) ===== */
    header{
      position:sticky; top:0; z-index:50;
      background: rgba(234,242,255,.85);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }
    .nav{
      display:flex; align-items:center; justify-content:space-between;
      padding: 14px 0;
      gap: 14px;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 240px;
    }
    .logoMark{
      width:44px;height:44px;border-radius:14px;
      background: conic-gradient(from 220deg, var(--brand), var(--brand2), var(--brand));
      position:relative;
      box-shadow: 0 14px 30px rgba(63,111,255,.18);
      overflow:hidden;
      display:grid;
      place-items:center;
    }
    .logoSvg{
      width:100%;
      height:100%;
      object-fit:contain;
      filter: brightness(0) invert(1);
      position:relative;
      z-index:2;
    }
    .logoMark::after{
      content:""; position:absolute; inset:-60%;
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.75), transparent 55%);
      animation: shimmer 5.6s ease-in-out infinite;
    }
    @keyframes shimmer{
      0%,100%{transform:translate(12%,12%) rotate(0deg)}
      50%{transform:translate(-12%,-12%) rotate(25deg)}
    }
    .brand h1{margin:0;font-size:15px;line-height:1.2}
    .brand p{margin:0;font-size:12px;color:var(--muted)}

    /* ===== BUTTONS (SAME AS CODE 1) ===== */
    .actions{display:flex; gap:10px; align-items:center}
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.7);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 16px;
      cursor:pointer;
      font-weight: 900;
      transition: transform .2s ease, box-shadow .2s ease;
      display:inline-flex; align-items:center; gap:8px;
      user-select:none;
      white-space:nowrap;
      font-family:"Apple Gothic",system-ui,sans-serif;
    }
    .btn:hover{transform: translateY(-1px); box-shadow: var(--shadow)}
    .btn:active{transform: translateY(0px)}
    .btn.primary{
      border: none;
      background: linear-gradient(135deg, rgba(8,181,141,.95), rgba(63,111,255,.90));
      color:#06101a;
    }
    /* optional variants but still same "btn" shape */
    .btn.good{
      border:none;
      background: linear-gradient(135deg, rgba(22,163,74,.95), rgba(8,181,141,.75));
      color:#06101a;
    }
    .btn.bad{
      border:none;
      background: linear-gradient(135deg, rgba(225,29,72,.95), rgba(211,47,47,.75));
      color:#fff;
    }
    .btn.ghost{
      background: transparent;
      box-shadow:none;
    }
    .btn.ghost:hover{box-shadow: var(--shadow)}

    /* inputs/selects match rounded style */
    select, input, textarea{
      font-family:"Apple Gothic",system-ui,sans-serif;
    }
    select, input{
      width:auto;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(9,16,42,.16);
      font-weight: 900;
      background: rgba(255,255,255,.9);
      transition: box-shadow .12s ease, transform .12s ease, border-color .12s ease;
    }
    select:focus, input:focus{
      outline:none;
      box-shadow: 0 0 0 6px rgba(63,111,255,.12);
      border-color: rgba(63,111,255,.35);
    }

    main{padding: 44px 0 70px}

    /* ===== TOP TITLE ROW (SAME IDEA AS CODE 1 headRow) ===== */
    .headRow{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:16px;
      flex-wrap:wrap;
      margin-bottom: 16px;
    }
    h2{
      margin:0;
      font-size: 44px;
      letter-spacing:-1px;
      line-height:1.05;
    }
    .sub{
      margin:8px 0 0;
      color:var(--muted);
      font-weight: 650;
      line-height:1.8;
      max-width: 72ch;
    }

    /* ===== SAME "CARD CONTAINER" FEEL AS CODE 1 ===== */
    .simContainer{
      background: rgba(255,255,255,.80);
      border: 1px solid rgba(9,16,42,.12);
      border-radius: calc(var(--radius) + 2px);
      box-shadow: 0 12px 30px rgba(16,24,40,.08);
      padding: 16px;
      position:relative;
      overflow:hidden;
    }
    .simContainer::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(520px 220px at 70% 10%, rgba(8,181,141,.14), transparent 60%),
        radial-gradient(520px 240px at 20% 70%, rgba(63,111,255,.14), transparent 60%);
      opacity:.8;
      z-index:0;
    }
    .simContainer > *{position:relative; z-index:1}

    /* ===== ASSEMBLER LAYOUT ===== */
    .app{
      display:grid;
      grid-template-columns: 1.25fr .9fr;
      gap:16px;
      width:100%;              /* IMPORTANT: do NOT set max-width here */
    }
    @media (max-width: 1100px){
      .app{ grid-template-columns:1fr; }
      .editorWrap{ height:350px; }
    }

    /* Panels match Code 1 panel feel */
    .panel{
      border: 1px solid rgba(9,16,42,.12);
      border-radius: var(--radius);
      background: rgba(255,255,255,.85);
      padding: 12px;
      box-shadow: 0 10px 20px rgba(16,24,40,.06);
      position:relative;
      overflow:hidden;
      transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .panel:hover{
      transform: translateY(-2px);
      box-shadow: var(--shadow);
      border-color: rgba(63,111,255,.22);
    }
    .panel .hd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight: 900;
      margin-bottom: 10px;
      font-size: 14px;
    }
    .panel .bd{ }

    .pill{
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(9,16,42,.12);
      background: rgba(255,255,255,.75);
      user-select:none;
    }
    .pill code{
      font-family:var(--mono);
      background: rgba(63,111,255,.10);
      padding:2px 6px;
      border-radius:10px;
      border:1px solid rgba(63,111,255,.14);
      color: rgba(9,16,42,.92);
      font-weight:900;
    }

    /* Editor */
    .editorWrap{
      display:grid;
      grid-template-columns: 52px 1fr;
      height: 400px;
      background: var(--panel2);
      border-radius: 16px;
      border: 1px solid rgba(9,16,42,.12);
      overflow:hidden;
    }
    .gutter{
      background: rgba(255,255,255,.72);
      border-right:1px solid rgba(9,16,42,.12);
      padding:10px 0;
      font-family:var(--mono);
      font-size:12px;
      line-height:18px;
      color: rgba(15,23,42,.55);
      user-select:none;
      overflow:auto;
    }
    .line{
      display:flex;
      justify-content:space-between;
      padding:0 8px;
      gap:8px;
      align-items:center;
      height:18px;
    }
    .line .bp{
      width:10px; height:10px;
      border-radius:50%;
      border:1px solid rgba(15,23,42,.22);
      background: transparent;
      flex:0 0 auto;
    }
    .line.bpOn .bp{
      border-color: rgba(225,29,72,.75);
      background: rgba(225,29,72,.9);
      box-shadow: 0 0 0 2px rgba(225,29,72,.14);
    }
    .line.active{ background: rgba(63,111,255,.14); color: rgba(15,23,42,.92); }

    textarea{
      width:100%;
      height:100%;
      resize:none;
      border:0;
      outline:none;
      background: transparent;
      color: var(--text);
      padding:10px 12px;
      font-family: var(--mono);
      font-size:12.8px;
      line-height:18px;
      tab-size: 4;
    }

    .hint{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.55;
      font-weight:700;
    }

    .rightGrid{
      display:grid;
      grid-template-rows: auto auto 1fr;
      gap:16px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .kv{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border:1px solid rgba(9,16,42,.12);
      border-radius:16px;
      background: rgba(255,255,255,.75);
      font-family:var(--mono);
      font-size:12px;
      gap:10px;
    }
    .kv .k{ color: rgba(81,96,122,.95); font-weight:800; }
    .kv .v{ font-weight:900; }

    .flags{ display:flex; flex-wrap:wrap; gap:8px; }
    .flag{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(9,16,42,.12);
      background: rgba(255,255,255,.75);
      font-family:var(--mono);
      font-size:12px;
      color: rgba(81,96,122,.95);
      user-select:none;
    }
    .flag.on{
      border-color: rgba(22,163,74,.35);
      background: rgba(22,163,74,.12);
      color: rgba(15,23,42,.95);
      box-shadow: 0 0 0 2px rgba(22,163,74,.07);
    }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      padding:8px 10px;
      border-radius:16px;
      border:1px solid rgba(9,16,42,.12);
      background: rgba(255,255,255,.75);
      font-weight:900;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{ border-color: rgba(63,111,255,.35); background: rgba(63,111,255,.12); }

    .tabContent{ display:none; }
    .tabContent.active{ display:block; }

    .memBar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .memBar input{
      cursor:text;
      font-family:var(--mono);
      font-weight:900;
      width:170px;
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(9,16,42,.16);
    }

    .memDump{
      border:1px solid rgba(9,16,42,.12);
      border-radius:16px;
      background: rgba(255,255,255,.75);
      padding:10px;
      overflow:auto;
      max-height:360px;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.6;
      white-space:pre;
      box-shadow: inset 0 1px 0 rgba(15,23,42,.04);
    }

    .out{
      border:1px solid rgba(9,16,42,.12);
      border-radius:16px;
      background: rgba(255,255,255,.75);
      padding:10px;
      overflow:auto;
      max-height:250px;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.55;
      white-space:pre-wrap;
      box-shadow: inset 0 1px 0 rgba(15,23,42,.04);
    }
    .out .err{ color: var(--bad); font-weight:900; }
    .out .warn{ color: #b45309; font-weight:900; }
    .out .ok{ color: var(--good); font-weight:900; }

    /* small toolbar layout */
    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }
  </style>
</head>

<body>
  <header>
    <div class="container nav">
      <a class="brand" href="../../" aria-label="Home">
        <div class="logoMark" aria-hidden="true">
          <img class="logoSvg" src="../../assets/mae.svg" alt="">
        </div>
        <div>
          <h1>MAE Academy</h1>
          <p>Assembler Simulator</p>
        </div>
      </a>

      <div class="actions">
        <a class="btn" href="../">Back to Simulations</a>
        <a class="btn primary" href="../../#contact">Start ↗</a>
      </div>
    </div>
  </header>

  <main>
    <div class="container">
      <!-- SAME TOP BODY FEEL AS CODE 1 -->
      <div class="headRow">
        <div>
          <h2>Assembler</h2>
          <div class="sub">16-bit Assembly Emulator (MASM-like subset) • Supports OFFSET, ORG, DB/DW/DD, strings, AL/AH.., TEST, LOOP, BYTE/WORD/DWORD PTR</div>
        </div>

        <div class="toolbar">
          <button class="btn primary" id="runBtn" title="Ctrl+Enter" type="button">Run</button>
          <button class="btn good" id="stepBtn" title="F10" type="button">Step</button>
          <button class="btn bad" id="resetBtn" title="Ctrl+R" type="button">Reset</button>
          <button class="btn" id="assembleBtn" type="button">Assemble</button>

          <select id="exampleSel" title="Load example">
            <option value="">Load example…</option>
            <option value="case">Toggle Case (your style)</option>
            <option value="data">DB/DW/DD + PTR demo</option>
          </select>

          <select id="baseSel" title="Display base">
            <option value="hex">HEX</option>
            <option value="dec">DEC</option>
          </select>

          <span class="pill" id="statusPill">Idle</span>
        </div>
      </div>

      <div class="simContainer">
        <div class="app">
          <section class="panel">
            <div class="hd">
              <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:14px; font-weight:1000;">Code Editor</span>
              </div>
              <div class="pill">Comments: <code>;</code> • Click line numbers to toggle breakpoints</div>
            </div>

            <div class="bd">
              <div class="editorWrap">
                <div class="gutter" id="gutter"></div>
                <textarea id="code" spellcheck="false"></textarea>
              </div>

              <div class="hint">
                <b>Numbers:</b> <span class="pill"><code>123</code></span> <span class="pill"><code>0x7B</code></span> <span class="pill"><code>7Bh</code></span> &nbsp;•&nbsp;
                <b>Data:</b> <span class="pill"><code>DB</code></span> <span class="pill"><code>DW</code></span> <span class="pill"><code>DD</code></span> (supports <code>"text"</code> and <code>'A'</code>) &nbsp;•&nbsp;
                <b>Memory:</b> <span class="pill"><code>[SI]</code></span> <span class="pill"><code>[DI+2]</code></span> <span class="pill"><code>[0x200]</code></span> &nbsp;•&nbsp;
                <b>Size:</b> <span class="pill"><code>BYTE PTR</code></span> <span class="pill"><code>WORD PTR</code></span> <span class="pill"><code>DWORD PTR</code></span> &nbsp;•&nbsp;
                <b>Addr:</b> <span class="pill"><code>OFFSET label</code></span>
              </div>
            </div>
          </section>

          <div class="rightGrid">
            <section class="panel">
              <div class="hd">
                <span>CPU State</span>
                <span class="pill">Registers: 16-bit + 8-bit views</span>
              </div>
              <div class="bd">
                <div class="grid2" id="regsGrid"></div>
                <div style="height:10px"></div>
                <div class="flags" id="flagsRow"></div>
                <div style="height:10px"></div>
                <div class="kv"><span class="k">Cycles</span><span class="v" id="cycles">0</span></div>
              </div>
            </section>

            <section class="panel">
              <div class="hd">
                <span>Inspector</span>
                <div class="tabs">
                  <div class="tab active" data-tab="memory">Memory</div>
                  <div class="tab" data-tab="output">Output</div>
                </div>
              </div>
              <div class="bd">
                <div class="tabContent active" id="tab-memory">
                  <div class="memBar">
                    <span class="pill">View from</span>
                    <input id="memStart" value="0x0100" />
                    <button class="btn" id="memRefresh" type="button">Refresh</button>
                    <span class="pill">64KB RAM</span>
                  </div>
                  <div class="memDump" id="memDump"></div>
                </div>

                <div class="tabContent" id="tab-output">
                  <div class="out" id="out"></div>
                  <div class="hint">Assemble checks syntax/labels/data. Run executes with safety step limit.</div>
                </div>
              </div>
            </section>

            <section class="panel">
              <div class="hd">
                <span>Practical Notes</span>
                <span class="pill">ORG affects data origin here</span>
              </div>
              <div class="bd">
                <div class="hint" style="margin:0">
                  • <code>ORG 100h</code> sets the <b>data pointer</b> (so <code>STR: DB "ab"</code> becomes at 0100h).<br>
                  • You can use <code>MOV SI, OFFSET STR</code> (supported).<br>
                  • Default memory read size is BYTE unless you specify <code>WORD PTR</code>/<code>DWORD PTR</code>.
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>
  </main>

<script>
  // Page transition
  window.addEventListener('load', () => {
    document.body.style.opacity = '1';
  });
  document.addEventListener('click', e => {
    const link = e.target.closest('a');
    if (link && link.href && !link.href.startsWith('javascript') && !link.target) {
      e.preventDefault();
      document.body.style.opacity = '0';
      setTimeout(() => {
        window.location = link.href;
      }, 500);
    }
  });

(() => {
  const el = (id) => document.getElementById(id);
  const codeEl = el("code");
  const gutterEl = el("gutter");
  const outEl = el("out");
  const memDumpEl = el("memDump");
  const statusPill = el("statusPill");
  const baseSel = el("baseSel");
  const memStartEl = el("memStart");
  const cyclesEl = el("cycles");
  const regsGrid = el("regsGrid");
  const flagsRow = el("flagsRow");

  const LS_CODE = "asm_emulator_code_v3";
  const LS_BPS  = "asm_emulator_bps_v3";

  function setStatus(text, kind="idle"){
    statusPill.textContent = text;
    statusPill.style.borderColor =
      kind==="ok" ? "rgba(22,163,74,.35)" :
      kind==="err"? "rgba(225,29,72,.35)" :
      kind==="run"? "rgba(63,111,255,.35)" :
      "rgba(15,23,42,.14)";
    statusPill.style.background =
      kind==="ok" ? "rgba(22,163,74,.10)" :
      kind==="err"? "rgba(225,29,72,.10)" :
      kind==="run"? "rgba(63,111,255,.10)" :
      "rgba(255,255,255,.70)";
  }

  function clearOutput(){ outEl.innerHTML = ""; }
  function logLine(msg, cls=""){
    const span = document.createElement("span");
    span.className = cls;
    span.textContent = msg + "\n";
    outEl.appendChild(span);
    outEl.scrollTop = outEl.scrollHeight;
  }

  function clamp16(x){ return ((x % 0x10000) + 0x10000) & 0xFFFF; }
  function clamp8(x){ return ((x % 0x100) + 0x100) & 0xFF; }

  function parseNumber(tok){
    const t = tok.trim();
    if(!t) return null;
    if(/^0x[0-9a-f]+$/i.test(t)) return parseInt(t,16);
    if(/^[0-9a-f]+h$/i.test(t)) return parseInt(t.slice(0,-1),16);
    if(/^[+-]?\d+$/.test(t)) return parseInt(t,10);
    return null;
  }

  function fmt(n, width=4){
    const base = baseSel.value;
    if(base === "dec") return String(n >>> 0);
    const hex = (n >>> 0).toString(16).toUpperCase().padStart(width,"0");
    return "0x" + hex;
  }

  // ---- CPU model ----
  const REG16 = ["AX","BX","CX","DX","SI","DI","BP","SP","IP"];
  const REG8  = ["AL","AH","BL","BH","CL","CH","DL","DH"];
  const FLAGS = ["ZF","SF","CF","OF"];

  const cpu = {
    regs: { AX:0,BX:0,CX:0,DX:0,SI:0,DI:0,BP:0,SP:0xFFFE,IP:0 },
    flags:{ ZF:0,SF:0,CF:0,OF:0 },
    cycles:0
  };

  // 64KB RAM
  const mem = new Uint8Array(0x10000);

  // Program + mappings
  let program = [];
  let ipToLine = new Map();
  let lineToIp = new Map();
  let labels = new Map();

  // ORG / data pointer
  let dataPtrDefault = 0x0100;
  let dataPtr = dataPtrDefault;

  // Breakpoints by line number
  let breakpoints = new Set();

  // ---- Editor gutter ----
  function getLines(){ return codeEl.value.replace(/\r\n/g,"\n").split("\n"); }

  function refreshGutter(){
    const lines = getLines();
    const activeLine = ipToLine.get(cpu.regs.IP) ?? null;
    gutterEl.innerHTML = "";
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const div = document.createElement("div");
      div.className = "line";
      if(breakpoints.has(ln)) div.classList.add("bpOn");
      if(activeLine === ln) div.classList.add("active");
      const bp = document.createElement("div"); bp.className="bp";
      const num = document.createElement("div"); num.textContent = ln;
      div.appendChild(bp); div.appendChild(num);
      div.addEventListener("click", () => {
        if(breakpoints.has(ln)) breakpoints.delete(ln); else breakpoints.add(ln);
        localStorage.setItem(LS_BPS, JSON.stringify([...breakpoints]));
        refreshGutter();
      });
      gutterEl.appendChild(div);
    }
  }

  codeEl.addEventListener("input", () => {
    localStorage.setItem(LS_CODE, codeEl.value);
    program = [];
    refreshGutter();
  });
  codeEl.addEventListener("scroll", () => { gutterEl.scrollTop = codeEl.scrollTop; });

  function loadBreakpoints(){
    try{
      const raw = localStorage.getItem(LS_BPS);
      if(raw) breakpoints = new Set(JSON.parse(raw));
    }catch{}
  }

  // ---- Helpers ----
  function stripComment(line){
    const idx = line.indexOf(";");
    return (idx>=0 ? line.slice(0,idx) : line).trim();
  }

  function tokenizeCommaAware(s){
    const parts = [];
    let cur = "";
    let depth = 0;
    for(const ch of s){
      if(ch === "[") depth++;
      if(ch === "]") depth--;
      if(ch === "," && depth === 0){
        parts.push(cur.trim()); cur="";
      }else cur += ch;
    }
    if(cur.trim()) parts.push(cur.trim());
    return parts;
  }

  // ---- Register access (16/8) ----
  function getReg16(name){ return cpu.regs[name] & 0xFFFF; }
  function setReg16(name,val){ cpu.regs[name] = clamp16(val); }

  function getReg8(name){
    const map = {
      AL:["AX",0], AH:["AX",8],
      BL:["BX",0], BH:["BX",8],
      CL:["CX",0], CH:["CX",8],
      DL:["DX",0], DH:["DX",8],
    };
    const [r,shift] = map[name];
    return (getReg16(r) >> shift) & 0xFF;
  }
  function setReg8(name,val){
    const map = {
      AL:["AX",0], AH:["AX",8],
      BL:["BX",0], BH:["BX",8],
      CL:["CX",0], CH:["CX",8],
      DL:["DX",0], DH:["DX",8],
    };
    const [r,shift] = map[name];
    const v = clamp8(val);
    const cur = getReg16(r);
    const mask = ~(0xFF << shift) & 0xFFFF;
    setReg16(r, (cur & mask) | (v << shift));
  }

  function isReg16(n){ return REG16.includes(n); }
  function isReg8(n){ return REG8.includes(n); }

  // ---- Flags math ----
  function setZS(width, value){
    if(width === 8){
      const v = value & 0xFF;
      cpu.flags.ZF = (v === 0) ? 1 : 0;
      cpu.flags.SF = ((v & 0x80) !== 0) ? 1 : 0;
    }else{
      const v = value & 0xFFFF;
      cpu.flags.ZF = (v === 0) ? 1 : 0;
      cpu.flags.SF = ((v & 0x8000) !== 0) ? 1 : 0;
    }
  }

  function add16(a,b){
    const sum = a + b;
    const res = sum & 0xFFFF;
    cpu.flags.CF = (sum > 0xFFFF) ? 1 : 0;
    const sa = (a & 0x8000) !== 0, sb = (b & 0x8000) !== 0, sr = (res & 0x8000) !== 0;
    cpu.flags.OF = (sa === sb && sa !== sr) ? 1 : 0;
    setZS(16,res);
    return res;
  }

  function sub16(a,b){
    const diff = a - b;
    const res = diff & 0xFFFF;
    cpu.flags.CF = (diff < 0) ? 1 : 0;
    const sa = (a & 0x8000) !== 0, sb = (b & 0x8000) !== 0, sr = (res & 0x8000) !== 0;
    cpu.flags.OF = (sa !== sb && sa !== sr) ? 1 : 0;
    setZS(16,res);
    return res;
  }

  // ---- Memory (Little Endian) ----
  function read8(addr){ return mem[addr & 0xFFFF] & 0xFF; }
  function write8(addr, v){ mem[addr & 0xFFFF] = clamp8(v); }

  // ---- Operand parsing ----
  function parseMemInside(inside){
    let expr = inside.replace(/\s+/g,"");
    expr = expr.replace(/-/g,"+-");
    const chunks = expr.split("+").filter(Boolean);

    let baseReg = null;
    let offset = 0;

    for(const c of chunks){
      const up = c.toUpperCase();
      if(isReg16(up)) baseReg = up;
      else{
        const n = parseNumber(up);
        if(n === null) return { ok:false, error:`Bad memory expr: [${inside}]` };
        offset += n;
      }
    }
    return { ok:true, baseReg, offset: clamp16(offset) };
  }

  function parseOperand(raw){
    let t = raw.trim();
    if(!t) return { type:"bad", error:"Empty operand" };
    let up = t.toUpperCase().replace(/\s+/g," ").trim();

    let size = null; // 8/16
    const ptrMatch = up.match(/^(BYTE|WORD)\s+PTR\s+(.+)$/i);
    if(ptrMatch){
      size = ptrMatch[1].toUpperCase() === "BYTE" ? 8 : 16;
      up = ptrMatch[2].trim();
    }

    const offMatch = up.match(/^OFFSET\s+([A-Z_.$][A-Z0-9_.$]*)$/i);
    if(offMatch) return { type:"offset", name: offMatch[1], size:16 };

    if(isReg16(up)) return { type:"reg16", name: up, size:16 };
    if(isReg8(up))  return { type:"reg8",  name: up, size:8 };

    if(up.startsWith("[") && up.endsWith("]")){
      const parsed = parseMemInside(up.slice(1,-1));
      if(!parsed.ok) return { type:"bad", error: parsed.error };
      return { type:"mem", baseReg: parsed.baseReg, offset: parsed.offset, size: size ?? 8 };
    }

    const num = parseNumber(up);
    if(num !== null) return { type:"imm", value: num >>> 0, size:16 };

    if(/^[A-Z_.$][A-Z0-9_.$]*$/i.test(up)) return { type:"label", name: up, size:16 };

    return { type:"bad", error:`Unknown operand: ${raw}` };
  }

  function addrOfMem(op){
    const base = op.baseReg ? getReg16(op.baseReg) : 0;
    return clamp16(base + (op.offset ?? 0));
  }

  function evalOperand(op){
    if(op.type === "imm") return op.value >>> 0;
    if(op.type === "reg16") return getReg16(op.name);
    if(op.type === "reg8")  return getReg8(op.name);
    if(op.type === "mem"){
      const a = addrOfMem(op);
      return (op.size === 16) ? ((read8(a) | (read8(a+1) << 8)) & 0xFFFF) : read8(a);
    }
    throw new Error("Bad operand");
  }

  function writeOperand(op, value){
    if(op.type === "reg16"){ setReg16(op.name, value); return; }
    if(op.type === "reg8"){ setReg8(op.name, value); return; }
    if(op.type === "mem"){
      const a = addrOfMem(op);
      if(op.size === 16){
        const w = value & 0xFFFF;
        write8(a, w & 0xFF);
        write8(a+1, (w >> 8) & 0xFF);
      }else{
        write8(a, value);
      }
      return;
    }
    throw new Error("Destination must be reg or mem");
  }

  // ---- DB/DW parsing ----
  function parseDataItems(argStr, directive){
    const items = tokenizeCommaAware(argStr);
    if(items.length === 0) return { ok:false, error:`${directive} needs values` };

    const bytes = [];
    const pushWord = (w) => { bytes.push(w & 0xFF, (w >> 8) & 0xFF); };

    for(const itRaw of items){
      const it = itRaw.trim();
      if(!it) continue;

      const strMatch = it.match(/^"(.*)"$/);
      if(strMatch){
        const s = strMatch[1];
        for(let i=0;i<s.length;i++){
          const ch = s.charCodeAt(i) & 0xFF;
          if(directive === "DB") bytes.push(ch);
          else pushWord(ch);
        }
        continue;
      }

      const chrMatch = it.match(/^'(.*)'$/);
      if(chrMatch){
        const s = chrMatch[1];
        const ch = (s.length ? s.charCodeAt(0) : 0) & 0xFF;
        if(directive === "DB") bytes.push(ch);
        else pushWord(ch);
        continue;
      }

      const n = parseNumber(it.toUpperCase());
      if(n === null) return { ok:false, error:`${directive} value must be number/string (got "${it}")` };

      if(directive === "DB") bytes.push(n & 0xFF);
      else pushWord(n & 0xFFFF);
    }

    return { ok:true, bytes };
  }

  // ---- Assembler (2-pass minimal) ----
  function assemble(){
    clearOutput();
    setStatus("Assembling…","run");

    const lines = getLines();
    labels = new Map();
    program = [];
    ipToLine = new Map();
    lineToIp = new Map();
    mem.fill(0);

    dataPtr = dataPtrDefault;

    // pre-scan ORG
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const raw = stripComment(lines[i]);
      if(!raw) continue;
      const m = raw.toUpperCase().trim().match(/^ORG\s+(.+)$/);
      if(m){
        const n = parseNumber(m[1].trim());
        if(n === null){
          logLine(`Line ${ln}: ORG needs numeric value`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        dataPtr = clamp16(n);
      }
    }

    // pass1: labels + data size + instruction count
    let ip = 0;
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      let raw = stripComment(lines[i]);
      if(!raw) continue;
      if(/^ORG\s+/i.test(raw)) continue;

      let rest = raw;
      const labelMatch = rest.match(/^([A-Z_.$][A-Z0-9_.$]*):/i);
      let labelName = null;
      if(labelMatch){
        labelName = labelMatch[1].toUpperCase();
        rest = rest.slice(labelMatch[0].length).trim();
      }

      const upRest = rest.toUpperCase();
      const isData = upRest.startsWith("DB ") || upRest.startsWith("DW ");

      if(labelName){
        if(labels.has(labelName)){
          logLine(`Line ${ln}: Duplicate label "${labelName}"`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        labels.set(labelName, isData ? dataPtr : ip);
      }

      if(!rest) continue;

      if(isData){
        const dir = upRest.slice(0,2); // DB/DW
        const parsed = parseDataItems(rest.slice(2).trim(), dir);
        if(!parsed.ok){
          logLine(`Line ${ln}: ${parsed.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        dataPtr = clamp16(dataPtr + parsed.bytes.length);
      }else{
        ip++;
      }
    }

    // pass2: emit data + program
    dataPtr = dataPtrDefault;
    for(let i=0;i<lines.length;i++){
      const raw = stripComment(lines[i]);
      if(!raw) continue;
      const m = raw.toUpperCase().trim().match(/^ORG\s+(.+)$/);
      if(m){
        const n = parseNumber(m[1].trim());
        if(n !== null) dataPtr = clamp16(n);
      }
    }

    ip = 0;
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const rawLine = lines[i];
      let raw = stripComment(rawLine);
      if(!raw) continue;
      if(/^ORG\s+/i.test(raw)) continue;

      let rest = raw;
      const labelMatch = rest.match(/^([A-Z_.$][A-Z0-9_.$]*):/i);
      if(labelMatch){
        rest = rest.slice(labelMatch[0].length).trim();
        if(!rest) continue;
      }

      const upRest = rest.toUpperCase();
      if(upRest.startsWith("DB ") || upRest.startsWith("DW ")){
        const dir = upRest.slice(0,2);
        const parsed = parseDataItems(rest.slice(2).trim(), dir);
        if(!parsed.ok){
          logLine(`Line ${ln}: ${parsed.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        for(const b of parsed.bytes){
          write8(dataPtr, b);
          dataPtr = clamp16(dataPtr + 1);
        }
        continue;
      }

      const parts = rest.trim().split(/\s+/);
      const op = parts[0].toUpperCase();
      const operandStr = rest.slice(parts[0].length).trim();
      const ops = operandStr ? tokenizeCommaAware(operandStr) : [];
      const args = ops.map(parseOperand);

      for(const a of args){
        if(a.type === "bad"){
          logLine(`Line ${ln}: ${a.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
      }

      // resolve labels + OFFSET
      for(let k=0;k<args.length;k++){
        const a = args[k];
        if(a.type === "label"){
          const val = labels.get(a.name.toUpperCase());
          if(val === undefined){
            logLine(`Line ${ln}: Unknown label "${a.name}"`, "err");
            setStatus("Assemble error","err");
            return false;
          }
          args[k] = { type:"imm", value: val >>> 0, size:16 };
        }
        if(a.type === "offset"){
          const val = labels.get(a.name.toUpperCase());
          if(val === undefined){
            logLine(`Line ${ln}: Unknown label "${a.name}"`, "err");
            setStatus("Assemble error","err");
            return false;
          }
          args[k] = { type:"imm", value: val >>> 0, size:16 };
        }
      }

      program.push({ op, args, line: ln, src: rawLine });
      lineToIp.set(ln, ip);
      ipToLine.set(ip, ln);
      ip++;
    }

    logLine("Assemble OK ✅", "ok");
    logLine(`Instructions: ${program.length} • Labels: ${labels.size}`, "ok");
    setStatus("Assembled","ok");
    return true;
  }

  // ---- Execution ----
  function resetCPU(keepMemory=true){
    cpu.regs.AX=0; cpu.regs.BX=0; cpu.regs.CX=0; cpu.regs.DX=0;
    cpu.regs.SI=0; cpu.regs.DI=0; cpu.regs.BP=0; cpu.regs.SP=0xFFFE;
    cpu.regs.IP=0;
    cpu.flags.ZF=0; cpu.flags.SF=0; cpu.flags.CF=0; cpu.flags.OF=0;
    cpu.cycles=0;
    if(!keepMemory) mem.fill(0);
    updateUI();
    refreshGutter();
    refreshMemory();
  }

  function stepOnce(){
    if(cpu.regs.IP < 0 || cpu.regs.IP >= program.length){
      logLine("Reached end of program (halt).", "warn");
      setStatus("Stopped","ok");
      return false;
    }

    const inst = program[cpu.regs.IP];
    const op = inst.op;
    const a0 = inst.args[0];
    const a1 = inst.args[1];
    const nextIP = cpu.regs.IP + 1;

    try{
      switch(op){
        case "HLT":
          cpu.regs.IP = nextIP;
          cpu.cycles++;
          logLine(`HLT at line ${inst.line}`, "ok");
          setStatus("HLT (stopped)","ok");
          updateUI(); refreshMemory(); refreshGutter();
          return false;

        case "MOV":{
          if(inst.args.length !== 2) throw new Error("MOV needs 2 operands");
          const v = evalOperand(a1);
          writeOperand(a0, v);
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(a0.size ?? 16, v);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "ADD":{
          if(inst.args.length !== 2) throw new Error("ADD needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const left = evalOperand(a0);
          const right = evalOperand(a1);
          const res = (w===8) ? ((left + right) & 0xFF) : add16(left, right);
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "SUB":{
          if(inst.args.length !== 2) throw new Error("SUB needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const left = evalOperand(a0);
          const right = evalOperand(a1);
          const res = (w===8) ? ((left - right) & 0xFF) : sub16(left, right);
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "INC":{
          if(inst.args.length !== 1) throw new Error("INC needs 1 operand");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const v = evalOperand(a0);
          const oldCF = cpu.flags.CF;
          const res = (w===8) ? ((v + 1) & 0xFF) : add16(v, 1);
          cpu.flags.CF = oldCF;
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "AND":{
          if(inst.args.length !== 2) throw new Error("AND needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) & evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          writeOperand(a0,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "XOR":{
          if(inst.args.length !== 2) throw new Error("XOR needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) ^ evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          writeOperand(a0,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "TEST":{
          if(inst.args.length !== 2) throw new Error("TEST needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) & evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "JMP":{
          if(inst.args.length !== 1) throw new Error("JMP needs 1 operand");
          cpu.regs.IP = clamp16(evalOperand(a0));
          cpu.cycles++;
          break;
        }

        case "JZ":{
          if(inst.args.length !== 1) throw new Error("JZ needs 1 operand");
          cpu.regs.IP = cpu.flags.ZF ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        case "JNZ":{
          if(inst.args.length !== 1) throw new Error("JNZ needs 1 operand");
          cpu.regs.IP = !cpu.flags.ZF ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        case "LOOP":{
          if(inst.args.length !== 1) throw new Error("LOOP needs 1 operand");
          setReg16("CX", (getReg16("CX") - 1) & 0xFFFF);
          cpu.regs.IP = (getReg16("CX") !== 0) ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        default:
          throw new Error(`Unknown instruction "${op}"`);
      }
    }catch(err){
      setStatus("Runtime error","err");
      logLine(`Runtime error at line ${inst.line}: ${err.message}`, "err");
      updateUI(); refreshMemory(); refreshGutter();
      return false;
    }

    updateUI();
    refreshMemory();
    refreshGutter();
    return true;
  }

  function runProgram(){
    clearOutput();
    if(!assemble()){
      return;
    }
    resetCPU(true);
    setStatus("Running…","run");

    const maxSteps = 200000;
    let steps = 0;

    while(steps < maxSteps){
      const curLine = ipToLine.get(cpu.regs.IP);
      if(curLine && breakpoints.has(curLine) && steps > 0){
        setStatus(`Paused at breakpoint (line ${curLine})`,"run");
        logLine(`Paused at breakpoint on line ${curLine}.`, "warn");
        return;
      }
      const ok = stepOnce();
      steps++;
      if(!ok) return;
    }

    setStatus("Stopped (max steps)","err");
    logLine("Stopped: exceeded max steps (possible infinite loop).", "err");
  }

  // ---- UI ----
  function updateUI(){
    regsGrid.innerHTML = "";

    const pairs = [
      ["AX", getReg16("AX"), 4], ["BX", getReg16("BX"), 4],
      ["CX", getReg16("CX"), 4], ["DX", getReg16("DX"), 4],
      ["SI", getReg16("SI"), 4], ["DI", getReg16("DI"), 4],
      ["BP", getReg16("BP"), 4], ["SP", getReg16("SP"), 4],
      ["IP", getReg16("IP"), 4],
      ["AL", getReg8("AL"), 2], ["AH", getReg8("AH"), 2],
      ["BL", getReg8("BL"), 2], ["BH", getReg8("BH"), 2],
      ["CL", getReg8("CL"), 2], ["CH", getReg8("CH"), 2],
      ["DL", getReg8("DL"), 2], ["DH", getReg8("DH"), 2],
    ];

    for(const [k,v,w] of pairs){
      const div = document.createElement("div");
      div.className = "kv";
      div.innerHTML = `<span class="k">${k}</span><span class="v">${baseSel.value==="hex" ? fmt(v,w) : String(v)}</span>`;
      regsGrid.appendChild(div);
    }

    flagsRow.innerHTML = "";
    for(const f of FLAGS){
      const div = document.createElement("div");
      div.className = "flag" + (cpu.flags[f] ? " on" : "");
      div.textContent = `${f}=${cpu.flags[f] ? 1 : 0}`;
      flagsRow.appendChild(div);
    }

    cyclesEl.textContent = String(cpu.cycles);
  }

  function parseAddrInput(s){
    const n = parseNumber(s.trim());
    return (n === null) ? null : clamp16(n);
  }

  function refreshMemory(){
    let start = parseAddrInput(memStartEl.value);
    if(start === null) start = 0x0100;

    const rows = 16, cols = 16;
    let out = "";
    for(let r=0;r<rows;r++){
      const addr = (start + r*cols) & 0xFFFF;
      out += fmt(addr,4) + "  ";
      let ascii = "";
      for(let c=0;c<cols;c++){
        const b = mem[(addr+c) & 0xFFFF];
        out += b.toString(16).toUpperCase().padStart(2,"0") + " ";
        ascii += (b>=32 && b<=126) ? String.fromCharCode(b) : ".";
      }
      out += " |" + ascii + "|\n";
    }
    memDumpEl.textContent = out;
  }

  function activateTab(name){
    document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
    document.querySelectorAll(".tabContent").forEach(c => c.classList.toggle("active", c.id === "tab-" + name));
  }
  document.querySelectorAll(".tab").forEach(t => t.addEventListener("click", () => activateTab(t.dataset.tab)));

  // Buttons
  el("assembleBtn").addEventListener("click", () => {
    if(assemble()){
      resetCPU(true);
    }
  });

  el("runBtn").addEventListener("click", runProgram);

  el("stepBtn").addEventListener("click", () => {
    if(program.length === 0){
      clearOutput();
      if(!assemble()){ return; }
      resetCPU(true);
      setStatus("Ready to step","run");
      logLine("Step mode ready. Press Step again.", "ok");
      return;
    }
    setStatus("Stepping…","run");
    const ok = stepOnce();
    if(!ok) setStatus("Stopped","ok");
  });

  el("resetBtn").addEventListener("click", () => {
    resetCPU(true);
    setStatus("Reset","ok");
    logLine("Reset OK.", "ok");
  });

  baseSel.addEventListener("change", () => { updateUI(); refreshMemory(); });
  el("memRefresh").addEventListener("click", refreshMemory);

  el("exampleSel").addEventListener("change", (e) => {
    const v = e.target.value;
    if(!v) return;

    const EX = {
      case: `ORG 100h
MOV SI, OFFSET STR
MOV CX, 2

L:  MOV AL, BYTE PTR [SI]
    XOR AL, 20h
    MOV BYTE PTR [SI], AL
    INC SI
    LOOP L
HLT

STR: DB "ab"
`,
      data: `ORG 200h
W1: DW 1234h
S1: DB "Hi", 0

MOV SI, OFFSET W1
; read/write word
MOV AX, WORD PTR [SI]
ADD AX, 1
MOV WORD PTR [SI], AX
HLT
`
    };

    codeEl.value = EX[v];
    localStorage.setItem(LS_CODE, codeEl.value);
    program = [];
    refreshGutter();
    clearOutput();
    setStatus("Loaded example","ok");
    e.target.value = "";
  });

  window.addEventListener("keydown", (e) => {
    if(e.ctrlKey && e.key === "Enter"){ e.preventDefault(); runProgram(); }
    if(e.key === "F10"){ e.preventDefault(); el("stepBtn").click(); }
    if(e.ctrlKey && (e.key === "r" || e.key === "R")){ e.preventDefault(); el("resetBtn").click(); }
  });

  function boot(){
    const saved = localStorage.getItem(LS_CODE);
    codeEl.value = saved ?? `; Paste your MASM/TASM-like code here
; Example: Toggle Case

ORG 100h
MOV SI, OFFSET STR
MOV CX, 2

L:  MOV AL, BYTE PTR [SI]
    XOR AL, 20h
    MOV BYTE PTR [SI], AL
    INC SI
    LOOP L
HLT

STR: DB "ab"
`;
    loadBreakpoints();
    refreshGutter();
    updateUI();
    refreshMemory();
    setStatus("Idle","idle");
    clearOutput();
    logLine("Tip: Assemble first to validate OFFSET/DB/DW and labels.", "ok");
  }

  boot();
})();
</script>
</body>
</html>
