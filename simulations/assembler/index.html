<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MAE Academy — 16-bit Assembly Simulator</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#eaf2ff;
  --bg2:#f8fbff;
  --card:#ffffff;
  --text:#09102a;
  --muted:#4c5d88;
  --brand:#08b58d;
  --brand2:#3f6fff;
  --border: rgba(9,16,42,.14);
  --shadow: 0 22px 60px rgba(16,24,40,.12);
  --radius: 22px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:"Inter",system-ui;
  background:
    radial-gradient(900px 520px at 15% -10%, rgba(63,111,255,.18), transparent 55%),
    radial-gradient(900px 520px at 86% 0%, rgba(8,181,141,.16), transparent 55%),
    linear-gradient(180deg, var(--bg), var(--bg2));
  color:var(--text);
}
.container{width:min(1400px,94%);margin:auto}

header{
  position:sticky; top:0; z-index:50;
  background: rgba(234,242,255,.85);
  backdrop-filter: blur(10px);
  border-bottom:1px solid var(--border);
}
.nav{
  display:flex; justify-content:space-between; align-items:center;
  padding:14px 0;
}
.brand{
  display:flex; gap:12px; align-items:center;
}
.logo{
  width:44px;height:44px;border-radius:14px;
  background:linear-gradient(135deg,var(--brand),var(--brand2));
  box-shadow: 0 12px 30px rgba(63,111,255,.18);
}
.brand h1{margin:0;font-size:16px}
.brand p{margin:0;font-size:12px;color:var(--muted)}

main{padding:32px 0 60px}
.grid{
  display:grid;
  grid-template-columns: 1.25fr .75fr;
  gap:18px;
}
.card{
  background:rgba(255,255,255,.9);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:16px;
}
.hdRow{
  display:flex; justify-content:space-between; align-items:center;
  gap:10px; flex-wrap:wrap;
  margin-bottom:12px;
}
.titleBlock h2{margin:0;font-size:18px}
.titleBlock p{margin:4px 0 0;color:var(--muted);font-size:12px}

.btn{
  border:1px solid var(--border);
  background:white;
  padding:10px 14px;
  border-radius:14px;
  font-weight:900;
  cursor:pointer;
  transition:.15s ease;
}
.btn:hover{transform:translateY(-1px)}
.btn:active{transform:translateY(0)}
.btn.primary{
  background:linear-gradient(135deg,var(--brand),var(--brand2));
  border:none;
  color:white;
}
.btn.ghost{
  background:rgba(255,255,255,.5);
}
select,input{
  border:1px solid var(--border);
  background:white;
  padding:10px 12px;
  border-radius:14px;
  font-weight:800;
}

.editorWrap{
  display:grid;
  grid-template-columns: 54px 1fr;
  height:590px;
  background:#0b1220;
  border-radius:16px;
  overflow:hidden;
  border:1px solid rgba(9,16,42,.22);
}
.gutter{
  background:#0f1a2e;
  color:#9fb0d0;
  font-family:var(--mono);
  font-size:12px;
  padding:10px 0;
  overflow:auto;
  user-select:none;
}
.lineNo{
  display:flex; justify-content:space-between; align-items:center;
  padding:0 10px;
  height:18px;
  gap:8px;
  cursor:pointer;
}
.bpDot{
  width:10px;height:10px;border-radius:50%;
  border:1px solid rgba(255,255,255,.22);
}
.lineNo.bpOn .bpDot{
  background:#ff5c7c;
  border-color:#ff5c7c;
  box-shadow:0 0 0 2px rgba(255,92,124,.2);
}
.lineNo.active{
  background: rgba(63,111,255,.25);
  color:#fff;
}

textarea{
  background:#0b1220;
  color:#e6eefc;
  border:none;
  resize:none;
  outline:none;
  padding:12px;
  font-family:var(--mono);
  font-size:13px;
  line-height:18px;
  tab-size: 4;
}

.kv{
  display:flex; justify-content:space-between; align-items:center;
  border:1px solid var(--border);
  border-radius:14px;
  padding:8px 12px;
  font-family:var(--mono);
  font-size:13px;
  margin-bottom:8px;
  background:rgba(255,255,255,.75);
}
.kv .k{color:var(--muted);font-weight:900}
.kv .v{font-weight:900}

.flags{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px}
.flag{
  border:1px solid var(--border);
  border-radius:999px;
  padding:6px 10px;
  font-family:var(--mono);
  font-size:12px;
  background:rgba(255,255,255,.7);
}
.flag.on{
  background: rgba(8,181,141,.16);
  border-color: rgba(8,181,141,.35);
}

.tabs{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px}
.tab{
  padding:8px 10px;
  border-radius:14px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.7);
  font-weight:900;
  cursor:pointer;
}
.tab.active{
  border-color: rgba(63,111,255,.5);
  background: rgba(63,111,255,.14);
}
.panelBody{display:none}
.panelBody.active{display:block}

.out, .memDump{
  background:#0b1220;
  color:#e6eefc;
  font-family:var(--mono);
  font-size:12px;
  padding:12px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.10);
  overflow:auto;
}
.out{height:240px; white-space:pre-wrap}
.memDump{height:320px; white-space:pre}

.out .err{color:#ff5c7c;font-weight:900}
.out .warn{color:#ffcc66;font-weight:900}
.out .ok{color:#3ddc97;font-weight:900}

.hint{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  line-height:1.5;
}
.hint code{
  font-family:var(--mono);
  background:rgba(255,255,255,.6);
  padding:2px 6px;
  border-radius:10px;
  border:1px solid var(--border);
}

@media(max-width:1000px){
  .grid{grid-template-columns:1fr}
  .editorWrap{height:540px}
}
</style>
</head>

<body>
<header>
  <div class="container nav">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>MAE Academy</h1>
        <p>16-bit Assembly Simulator (MASM-like subset)</p>
      </div>
    </div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
      <select id="exampleSel" title="Load example">
        <option value="">Load example…</option>
        <option value="case">Toggle Case (ORG/OFFSET/DB)</option>
        <option value="ptr">PTR sizes demo</option>
      </select>
      <select id="baseSel" title="Display base">
        <option value="hex">HEX</option>
        <option value="dec">DEC</option>
      </select>
      <div class="kv" style="margin:0; padding:8px 12px;">
        <span class="k">Status</span><span class="v" id="statusPill">Idle</span>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="container grid">

    <!-- LEFT: Editor -->
    <section class="card">
      <div class="hdRow">
        <div class="titleBlock">
          <h2>Code Editor</h2>
          <p>Supports: <b>ORG, OFFSET, DB/DW/DD, strings</b>, <b>BYTE/WORD/DWORD PTR</b>, and common instructions.</p>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn" id="assembleBtn">Assemble</button>
          <button class="btn primary" id="runBtn">Run</button>
          <button class="btn" id="stepBtn">Step</button>
          <button class="btn ghost" id="resetBtn">Reset</button>
        </div>
      </div>

      <div class="editorWrap">
        <div class="gutter" id="gutter"></div>
        <textarea id="code" spellcheck="false"></textarea>
      </div>

      <div class="hint">
        <b>Numbers:</b> <code>123</code>, <code>0x7B</code>, <code>7Bh</code>, <code>20h</code> •
        <b>Data:</b> <code>DB</code> <code>DW</code> <code>DD</code> supports <code>"text"</code> and <code>'A'</code> •
        <b>Labels:</b> supports both <code>STR:</code> and <code>STR DB "ab"</code> (no colon).
      </div>
    </section>

    <!-- RIGHT: CPU / Memory / Output -->
    <aside class="card">
      <div class="hdRow">
        <div class="titleBlock">
          <h2>Inspector</h2>
          <p>Registers, flags, memory dump, and assembler/runtime output.</p>
        </div>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="cpu">CPU</div>
        <div class="tab" data-tab="memory">Memory</div>
        <div class="tab" data-tab="output">Output</div>
      </div>

      <div class="panelBody active" id="tab-cpu">
        <div id="regsGrid"></div>
        <div style="height:8px"></div>
        <div class="flags" id="flagsRow"></div>
        <div class="kv"><span class="k">Cycles</span><span class="v" id="cycles">0</span></div>
      </div>

      <div class="panelBody" id="tab-memory">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px">
          <span class="kv" style="margin:0"><span class="k">View from</span><span class="v" style="display:none"></span></span>
          <input id="memStart" value="0x0100" style="width:160px" />
          <button class="btn" id="memRefresh">Refresh</button>
          <span class="kv" style="margin:0"><span class="k">RAM</span><span class="v">64KB</span></span>
        </div>
        <div class="memDump" id="memDump"></div>
      </div>

      <div class="panelBody" id="tab-output">
        <div class="out" id="out"></div>
        <div class="hint">Tip: click line numbers to toggle breakpoints. <code>Ctrl+Enter</code> run • <code>F10</code> step • <code>Ctrl+R</code> reset.</div>
      </div>
    </aside>

  </div>
</main>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const codeEl = el("code");
  const gutterEl = el("gutter");
  const outEl = el("out");
  const memDumpEl = el("memDump");
  const statusPill = el("statusPill");
  const baseSel = el("baseSel");
  const memStartEl = el("memStart");
  const cyclesEl = el("cycles");
  const regsGrid = el("regsGrid");
  const flagsRow = el("flagsRow");
  const exampleSel = el("exampleSel");

  const LS_CODE = "mae_asm_code_v1";
  const LS_BPS  = "mae_asm_bps_v1";

  function setStatus(text, kind="idle"){
    statusPill.textContent = text;
    statusPill.style.color =
      kind==="ok" ? "#0b7b62" :
      kind==="err"? "#b9203d" :
      kind==="run"? "#1f3bb3" :
      "#09102a";
  }

  function clearOutput(){ outEl.innerHTML = ""; }
  function logLine(msg, cls=""){
    const span = document.createElement("span");
    span.className = cls;
    span.textContent = msg + "\n";
    outEl.appendChild(span);
    outEl.scrollTop = outEl.scrollHeight;
  }

  function clamp16(x){ return ((x % 0x10000) + 0x10000) & 0xFFFF; }
  function clamp8(x){ return ((x % 0x100) + 0x100) & 0xFF; }

  function parseNumber(tok){
    const t = tok.trim();
    if(!t) return null;
    if(/^0x[0-9a-f]+$/i.test(t)) return parseInt(t,16);
    if(/^[0-9a-f]+h$/i.test(t)) return parseInt(t.slice(0,-1),16);
    if(/^[+-]?\d+$/.test(t)) return parseInt(t,10);
    return null;
  }

  function fmt(n, width=4){
    const base = baseSel.value;
    if(base === "dec") return String(n >>> 0);
    const hex = (n >>> 0).toString(16).toUpperCase().padStart(width,"0");
    return "0x" + hex;
  }

  // ---- CPU model ----
  const REG16 = ["AX","BX","CX","DX","SI","DI","BP","SP","IP"];
  const REG8  = ["AL","AH","BL","BH","CL","CH","DL","DH"];
  const FLAGS = ["ZF","SF","CF","OF"];

  const cpu = {
    regs: { AX:0,BX:0,CX:0,DX:0,SI:0,DI:0,BP:0,SP:0xFFFE,IP:0 },
    flags:{ ZF:0,SF:0,CF:0,OF:0 },
    cycles:0
  };

  // 64KB RAM
  const mem = new Uint8Array(0x10000);

  // Program + mappings
  let program = [];
  let ipToLine = new Map();
  let lineToIp = new Map();
  let labels = new Map(); // label -> numeric address (code IP or memory address)

  // ORG / data pointer
  let dataPtrDefault = 0x0100;
  let dataPtr = dataPtrDefault;

  // Breakpoints by line number
  let breakpoints = new Set();

  // ---- Editor gutter ----
  function getLines(){ return codeEl.value.replace(/\r\n/g,"\n").split("\n"); }

  function refreshGutter(){
    const lines = getLines();
    const activeLine = ipToLine.get(cpu.regs.IP) ?? null;
    gutterEl.innerHTML = "";
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const div = document.createElement("div");
      div.className = "lineNo";
      if(breakpoints.has(ln)) div.classList.add("bpOn");
      if(activeLine === ln) div.classList.add("active");

      const dot = document.createElement("div"); dot.className="bpDot";
      const num = document.createElement("div"); num.textContent = ln;

      div.appendChild(dot);
      div.appendChild(num);

      div.addEventListener("click", () => {
        if(breakpoints.has(ln)) breakpoints.delete(ln); else breakpoints.add(ln);
        localStorage.setItem(LS_BPS, JSON.stringify([...breakpoints]));
        refreshGutter();
      });

      gutterEl.appendChild(div);
    }
  }

  codeEl.addEventListener("input", () => {
    localStorage.setItem(LS_CODE, codeEl.value);
    program = [];
    refreshGutter();
  });

  codeEl.addEventListener("scroll", () => { gutterEl.scrollTop = codeEl.scrollTop; });

  function loadBreakpoints(){
    try{
      const raw = localStorage.getItem(LS_BPS);
      if(raw) breakpoints = new Set(JSON.parse(raw));
    }catch{}
  }

  // ---- Helpers ----
  function stripComment(line){
    const idx = line.indexOf(";");
    return (idx>=0 ? line.slice(0,idx) : line).trim();
  }

  function tokenizeCommaAware(s){
    const parts = [];
    let cur = "";
    let depth = 0;
    for(const ch of s){
      if(ch === "[") depth++;
      if(ch === "]") depth--;
      if(ch === "," && depth === 0){
        parts.push(cur.trim()); cur="";
      }else cur += ch;
    }
    if(cur.trim()) parts.push(cur.trim());
    return parts;
  }

  function isReg16(n){ return REG16.includes(n); }
  function isReg8(n){ return REG8.includes(n); }

  // ---- Register access (16/8) ----
  function getReg16(name){ return cpu.regs[name] & 0xFFFF; }
  function setReg16(name,val){ cpu.regs[name] = clamp16(val); }

  function getReg8(name){
    const map = {
      AL:["AX",0], AH:["AX",8],
      BL:["BX",0], BH:["BX",8],
      CL:["CX",0], CH:["CX",8],
      DL:["DX",0], DH:["DX",8],
    };
    const [r,shift] = map[name];
    return (getReg16(r) >> shift) & 0xFF;
  }

  function setReg8(name,val){
    const map = {
      AL:["AX",0], AH:["AX",8],
      BL:["BX",0], BH:["BX",8],
      CL:["CX",0], CH:["CX",8],
      DL:["DX",0], DH:["DX",8],
    };
    const [r,shift] = map[name];
    const v = clamp8(val);
    const cur = getReg16(r);
    const mask = ~(0xFF << shift) & 0xFFFF;
    setReg16(r, (cur & mask) | (v << shift));
  }

  // ---- Flags math ----
  function setZS(width, value){
    if(width === 8){
      const v = value & 0xFF;
      cpu.flags.ZF = (v === 0) ? 1 : 0;
      cpu.flags.SF = ((v & 0x80) !== 0) ? 1 : 0;
    }else{
      const v = value & 0xFFFF;
      cpu.flags.ZF = (v === 0) ? 1 : 0;
      cpu.flags.SF = ((v & 0x8000) !== 0) ? 1 : 0;
    }
  }

  function addN(width, a, b){
    if(width === 8){
      const sum = a + b;
      const res = sum & 0xFF;
      cpu.flags.CF = (sum > 0xFF) ? 1 : 0;
      const sa = (a & 0x80) !== 0, sb = (b & 0x80) !== 0, sr = (res & 0x80) !== 0;
      cpu.flags.OF = (sa === sb && sa !== sr) ? 1 : 0;
      setZS(8,res); return res;
    }else{
      const sum = a + b;
      const res = sum & 0xFFFF;
      cpu.flags.CF = (sum > 0xFFFF) ? 1 : 0;
      const sa = (a & 0x8000) !== 0, sb = (b & 0x8000) !== 0, sr = (res & 0x8000) !== 0;
      cpu.flags.OF = (sa === sb && sa !== sr) ? 1 : 0;
      setZS(16,res); return res;
    }
  }

  function subN(width, a, b){
    if(width === 8){
      const diff = a - b;
      const res = diff & 0xFF;
      cpu.flags.CF = (diff < 0) ? 1 : 0;
      const sa = (a & 0x80) !== 0, sb = (b & 0x80) !== 0, sr = (res & 0x80) !== 0;
      cpu.flags.OF = (sa !== sb && sa !== sr) ? 1 : 0;
      setZS(8,res); return res;
    }else{
      const diff = a - b;
      const res = diff & 0xFFFF;
      cpu.flags.CF = (diff < 0) ? 1 : 0;
      const sa = (a & 0x8000) !== 0, sb = (b & 0x8000) !== 0, sr = (res & 0x8000) !== 0;
      cpu.flags.OF = (sa !== sb && sa !== sr) ? 1 : 0;
      setZS(16,res); return res;
    }
  }

  // ---- Memory access ----
  function read8(addr){ return mem[addr & 0xFFFF] & 0xFF; }
  function write8(addr, v){ mem[addr & 0xFFFF] = clamp8(v); }

  function read16(addr){
    const a = addr & 0xFFFF;
    return (read8(a) | (read8(a+1) << 8)) & 0xFFFF;
  }
  function write16(addr, v){
    const a = addr & 0xFFFF;
    const w = v & 0xFFFF;
    write8(a, w & 0xFF);
    write8(a+1, (w >> 8) & 0xFF);
  }

  // ---- Operand parsing ----
  function parseMemInside(inside){
    let expr = inside.replace(/\s+/g,"");
    expr = expr.replace(/-/g,"+-");
    const chunks = expr.split("+").filter(Boolean);

    let baseReg = null;
    let offset = 0;

    for(const c of chunks){
      const up = c.toUpperCase();
      if(isReg16(up)){
        baseReg = up;
      }else{
        const n = parseNumber(up);
        if(n === null) return { ok:false, error:`Bad memory expr: [${inside}]` };
        offset += n;
      }
    }
    return { ok:true, baseReg, offset: clamp16(offset) };
  }

  function parseOperand(raw){
    let t = raw.trim();
    if(!t) return { type:"bad", error:"Empty operand" };
    let up = t.toUpperCase().replace(/\s+/g," ").trim();

    // SIZE PTR
    let size = null; // 8/16
    const ptrMatch = up.match(/^(BYTE|WORD)\s+PTR\s+(.+)$/i);
    if(ptrMatch){
      size = ptrMatch[1].toUpperCase() === "BYTE" ? 8 : 16;
      up = ptrMatch[2].trim();
    }

    // OFFSET label
    const offMatch = up.match(/^OFFSET\s+([A-Z_.$][A-Z0-9_.$]*)$/i);
    if(offMatch){
      return { type:"offset", name: offMatch[1], size: 16 };
    }

    if(isReg16(up)) return { type:"reg16", name: up, size: 16 };
    if(isReg8(up))  return { type:"reg8",  name: up, size: 8  };

    if(up.startsWith("[") && up.endsWith("]")){
      const inside = up.slice(1,-1);
      const parsed = parseMemInside(inside);
      if(!parsed.ok) return { type:"bad", error: parsed.error };
      return { type:"mem", baseReg: parsed.baseReg, offset: parsed.offset, size: size ?? 8 };
    }

    const num = parseNumber(up);
    if(num !== null) return { type:"imm", value: num >>> 0, size: 16 };

    if(/^[A-Z_.$][A-Z0-9_.$]*$/i.test(up)) return { type:"label", name: up, size: 16 };

    return { type:"bad", error:`Unknown operand: ${raw}` };
  }

  function addrOfMem(op){
    const base = op.baseReg ? getReg16(op.baseReg) : 0;
    return clamp16(base + (op.offset ?? 0));
  }

  function evalOperand(op){
    if(op.type === "imm") return op.value >>> 0;
    if(op.type === "reg16") return getReg16(op.name);
    if(op.type === "reg8")  return getReg8(op.name);
    if(op.type === "mem"){
      const a = addrOfMem(op);
      return (op.size === 16) ? read16(a) : read8(a);
    }
    throw new Error("Bad eval operand");
  }

  function writeOperand(op, value){
    if(op.type === "reg16"){ setReg16(op.name, value); return; }
    if(op.type === "reg8"){ setReg8(op.name, value); return; }
    if(op.type === "mem"){
      const a = addrOfMem(op);
      if(op.size === 16) write16(a, value);
      else write8(a, value);
      return;
    }
    throw new Error("Destination must be register or memory");
  }

  // ---- DB/DW/DD parsing ----
  function parseDataItems(argStr, directive){
    const items = tokenizeCommaAware(argStr);
    if(items.length === 0) return { ok:false, error:`${directive} needs values` };

    const bytes = [];
    const pushWord = (w) => { bytes.push(w & 0xFF, (w >> 8) & 0xFF); };

    for(const itRaw of items){
      const it = itRaw.trim();
      if(!it) continue;

      const strMatch = it.match(/^"(.*)"$/);
      if(strMatch){
        const s = strMatch[1];
        for(let i=0;i<s.length;i++){
          const ch = s.charCodeAt(i) & 0xFF;
          if(directive === "DB") bytes.push(ch);
          else pushWord(ch);
        }
        continue;
      }

      const chrMatch = it.match(/^'(.*)'$/);
      if(chrMatch){
        const s = chrMatch[1];
        const ch = (s.length ? s.charCodeAt(0) : 0) & 0xFF;
        if(directive === "DB") bytes.push(ch);
        else pushWord(ch);
        continue;
      }

      const n = parseNumber(it.toUpperCase());
      if(n === null) return { ok:false, error:`${directive} value must be number or string (got "${it}")` };

      if(directive === "DB") bytes.push(n & 0xFF);
      else pushWord(n & 0xFFFF);
    }

    return { ok:true, bytes };
  }

  // ---- Label handling (supports: "LBL:" and "LBL DB ...") ----
  function detectLabelPrefix(rest){
    // returns {label, after} or null
    const s = rest.trim();
    if(!s) return null;

    // Case 1: LABEL:
    let m = s.match(/^([A-Z_.$][A-Z0-9_.$]*):\s*(.*)$/i);
    if(m) return { label: m[1].toUpperCase(), after: (m[2] ?? "").trim() };

    // Case 2: LABEL <something>  (no colon)
    // Only treat as label if second token is DB/DW/DD or an instruction (opcode)
    const parts = s.split(/\s+/);
    if(parts.length >= 2 && /^[A-Z_.$][A-Z0-9_.$]*$/i.test(parts[0])){
      const maybeLabel = parts[0].toUpperCase();
      const second = parts[1].toUpperCase();
      const known = new Set(["ORG","DB","DW","DD","MOV","ADD","SUB","INC","DEC","AND","OR","XOR","TEST","CMP","JMP","JZ","JE","JNZ","JNE","LOOP","HLT"]);
      if(known.has(second)){
        return { label: maybeLabel, after: parts.slice(1).join(" ").trim() };
      }
    }
    return null;
  }

  // ---- Assembler ----
  function assemble(){
    clearOutput();
    setStatus("Assembling…","run");

    const lines = getLines();
    labels = new Map();
    program = [];
    ipToLine = new Map();
    lineToIp = new Map();

    mem.fill(0);
    dataPtr = dataPtrDefault;

    // Apply ORG (last one wins)
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const raw = stripComment(lines[i]);
      if(!raw) continue;
      const up = raw.toUpperCase().trim();
      const m = up.match(/^ORG\s+(.+)$/);
      if(m){
        const n = parseNumber(m[1].trim());
        if(n === null){
          logLine(`Line ${ln}: ORG needs numeric value`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        dataPtr = clamp16(n);
      }
    }

    // PASS1: define labels and count IP
    let ip = 0;
    let dataPtrPass1 = dataPtr;

    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      let raw = stripComment(lines[i]);
      if(!raw) continue;

      // ORG does not become instruction
      if(/^ORG\s+/i.test(raw)) continue;

      const lbl = detectLabelPrefix(raw);
      if(lbl){
        if(labels.has(lbl.label)){
          logLine(`Line ${ln}: Duplicate label "${lbl.label}"`, "err");
          setStatus("Assemble error","err");
          return false;
        }

        const afterUp = (lbl.after || "").toUpperCase();
        const isData = afterUp.startsWith("DB ") || afterUp.startsWith("DW ") || afterUp.startsWith("DD ");

        if(isData){
          labels.set(lbl.label, dataPtrPass1);
        }else{
          labels.set(lbl.label, ip);
        }

        raw = lbl.after;
        if(!raw) continue;
      }

      const up = raw.toUpperCase().trim();
      const isData = up.startsWith("DB ") || up.startsWith("DW ") || up.startsWith("DD ");
      if(isData){
        const dir = up.slice(0,2);
        const argStr = raw.slice(2).trim();
        const parsed = parseDataItems(argStr, dir);
        if(!parsed.ok){
          logLine(`Line ${ln}: ${parsed.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        dataPtrPass1 = clamp16(dataPtrPass1 + parsed.bytes.length);
      }else{
        ip++;
      }
    }

    // PASS2: emit program + write data
    // re-apply ORG for data pointer
    dataPtr = dataPtrDefault;
    for(let i=0;i<lines.length;i++){
      const raw = stripComment(lines[i]);
      if(!raw) continue;
      const up = raw.toUpperCase().trim();
      const m = up.match(/^ORG\s+(.+)$/);
      if(m){
        const n = parseNumber(m[1].trim());
        if(n !== null) dataPtr = clamp16(n);
      }
    }

    ip = 0;
    for(let i=0;i<lines.length;i++){
      const ln = i+1;
      const original = lines[i];
      let raw = stripComment(original);
      if(!raw) continue;

      if(/^ORG\s+/i.test(raw)) continue;

      const lbl = detectLabelPrefix(raw);
      if(lbl){
        raw = lbl.after;
        if(!raw) continue;
      }

      const up = raw.toUpperCase().trim();
      const isData = up.startsWith("DB ") || up.startsWith("DW ") || up.startsWith("DD ");
      if(isData){
        const dir = up.slice(0,2);
        const argStr = raw.slice(2).trim();
        const parsed = parseDataItems(argStr, dir);
        if(!parsed.ok){
          logLine(`Line ${ln}: ${parsed.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
        for(const b of parsed.bytes){
          write8(dataPtr, b);
          dataPtr = clamp16(dataPtr + 1);
        }
        continue;
      }

      // instruction
      const parts = raw.trim().split(/\s+/);
      const op = parts[0].toUpperCase();
      const operandStr = raw.slice(parts[0].length).trim();
      const ops = operandStr ? tokenizeCommaAware(operandStr) : [];
      const args = ops.map(parseOperand);

      for(const a of args){
        if(a.type === "bad"){
          logLine(`Line ${ln}: ${a.error}`, "err");
          setStatus("Assemble error","err");
          return false;
        }
      }

      // resolve labels + OFFSET now
      for(let k=0;k<args.length;k++){
        const a = args[k];
        if(a.type === "label" || a.type === "offset"){
          const name = a.name.toUpperCase();
          const val = labels.get(name);
          if(val === undefined){
            logLine(`Line ${ln}: Unknown label "${a.name}"`, "err");
            setStatus("Assemble error","err");
            return false;
          }
          args[k] = { type:"imm", value: val >>> 0, size:16 };
        }
      }

      program.push({ op, args, line: ln, src: original });
      lineToIp.set(ln, ip);
      ipToLine.set(ip, ln);
      ip++;
    }

    logLine("Assemble OK ✅", "ok");
    logLine(`Instructions: ${program.length} • Labels: ${labels.size}`, "ok");
    setStatus("Assembled","ok");
    return true;
  }

  // ---- Execution ----
  function resetCPU(keepMemory=true){
    cpu.regs.AX=0; cpu.regs.BX=0; cpu.regs.CX=0; cpu.regs.DX=0;
    cpu.regs.SI=0; cpu.regs.DI=0; cpu.regs.BP=0; cpu.regs.SP=0xFFFE;
    cpu.regs.IP=0;
    cpu.flags.ZF=0; cpu.flags.SF=0; cpu.flags.CF=0; cpu.flags.OF=0;
    cpu.cycles=0;
    if(!keepMemory) mem.fill(0);
    updateUI();
    refreshGutter();
    refreshMemory();
  }

  function stepOnce(){
    if(cpu.regs.IP < 0 || cpu.regs.IP >= program.length){
      logLine("Reached end of program (halt).", "warn");
      setStatus("Stopped","ok");
      return false;
    }

    const inst = program[cpu.regs.IP];
    const op = inst.op;
    const a0 = inst.args[0];
    const a1 = inst.args[1];
    const nextIP = cpu.regs.IP + 1;

    try{
      switch(op){
        case "HLT":
          cpu.regs.IP = nextIP;
          cpu.cycles++;
          logLine(`HLT at line ${inst.line}`, "ok");
          setStatus("HLT (stopped)","ok");
          updateUI(); refreshMemory(); refreshGutter();
          return false;

        case "MOV":{
          if(inst.args.length !== 2) throw new Error("MOV needs 2 operands");
          const v = evalOperand(a1);
          writeOperand(a0, v);
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(a0.size ?? 16, v);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "ADD":{
          if(inst.args.length !== 2) throw new Error("ADD needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = addN(w, evalOperand(a0), evalOperand(a1));
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "SUB":{
          if(inst.args.length !== 2) throw new Error("SUB needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = subN(w, evalOperand(a0), evalOperand(a1));
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "INC":{
          if(inst.args.length !== 1) throw new Error("INC needs 1 operand");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const oldCF = cpu.flags.CF;
          const res = addN(w, evalOperand(a0), 1);
          cpu.flags.CF = oldCF;
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "DEC":{
          if(inst.args.length !== 1) throw new Error("DEC needs 1 operand");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const oldCF = cpu.flags.CF;
          const res = subN(w, evalOperand(a0), 1);
          cpu.flags.CF = oldCF;
          writeOperand(a0, res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "AND":{
          if(inst.args.length !== 2) throw new Error("AND needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) & evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          writeOperand(a0,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "OR":{
          if(inst.args.length !== 2) throw new Error("OR needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) | evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          writeOperand(a0,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "XOR":{
          if(inst.args.length !== 2) throw new Error("XOR needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) ^ evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          writeOperand(a0,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "TEST":{
          if(inst.args.length !== 2) throw new Error("TEST needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          const res = (evalOperand(a0) & evalOperand(a1)) >>> 0;
          cpu.flags.CF=0; cpu.flags.OF=0;
          setZS(w,res);
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "CMP":{
          if(inst.args.length !== 2) throw new Error("CMP needs 2 operands");
          const w = a0.size ?? (a0.type==="reg8"?8:16);
          subN(w, evalOperand(a0), evalOperand(a1));
          cpu.regs.IP = nextIP; cpu.cycles++;
          break;
        }

        case "JMP":{
          if(inst.args.length !== 1) throw new Error("JMP needs 1 operand");
          cpu.regs.IP = clamp16(evalOperand(a0));
          cpu.cycles++;
          break;
        }

        case "JZ":
        case "JE":{
          if(inst.args.length !== 1) throw new Error(op+" needs 1 operand");
          cpu.regs.IP = cpu.flags.ZF ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        case "JNZ":
        case "JNE":{
          if(inst.args.length !== 1) throw new Error(op+" needs 1 operand");
          cpu.regs.IP = !cpu.flags.ZF ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        case "LOOP":{
          if(inst.args.length !== 1) throw new Error("LOOP needs 1 operand");
          setReg16("CX", (getReg16("CX") - 1) & 0xFFFF);
          cpu.regs.IP = (getReg16("CX") !== 0) ? clamp16(evalOperand(a0)) : nextIP;
          cpu.cycles++;
          break;
        }

        default:
          throw new Error(`Unknown instruction "${op}"`);
      }
    }catch(err){
      setStatus("Runtime error","err");
      logLine(`Runtime error at line ${inst.line}: ${err.message}`, "err");
      activateTab("output");
      updateUI(); refreshMemory(); refreshGutter();
      return false;
    }

    updateUI();
    refreshMemory();
    refreshGutter();
    return true;
  }

  function runProgram(){
    clearOutput();
    activateTab("output");
    if(!assemble()) return;

    resetCPU(true);
    setStatus("Running…","run");

    const maxSteps = 200000;
    let steps = 0;

    while(steps < maxSteps){
      const curLine = ipToLine.get(cpu.regs.IP);
      if(curLine && breakpoints.has(curLine) && steps > 0){
        setStatus(`Paused at BP line ${curLine}`,"run");
        logLine(`Paused at breakpoint on line ${curLine}.`, "warn");
        return;
      }
      const ok = stepOnce();
      steps++;
      if(!ok) return;
    }

    setStatus("Stopped (max steps)","err");
    logLine("Stopped: exceeded max steps (possible infinite loop).", "err");
  }

  // ---- UI ----
  function updateUI(){
    regsGrid.innerHTML = "";
    const pairs = [
      ["AX", getReg16("AX"), 4], ["BX", getReg16("BX"), 4],
      ["CX", getReg16("CX"), 4], ["DX", getReg16("DX"), 4],
      ["SI", getReg16("SI"), 4], ["DI", getReg16("DI"), 4],
      ["BP", getReg16("BP"), 4], ["SP", getReg16("SP"), 4],
      ["IP", getReg16("IP"), 4],
      ["AL", getReg8("AL"), 2], ["AH", getReg8("AH"), 2],
      ["BL", getReg8("BL"), 2], ["BH", getReg8("BH"), 2],
      ["CL", getReg8("CL"), 2], ["CH", getReg8("CH"), 2],
      ["DL", getReg8("DL"), 2], ["DH", getReg8("DH"), 2],
    ];

    for(const [k,v,w] of pairs){
      const div = document.createElement("div");
      div.className = "kv";
      div.innerHTML = `<span class="k">${k}</span><span class="v">${baseSel.value==="hex" ? fmt(v,w) : String(v)}</span>`;
      regsGrid.appendChild(div);
    }

    flagsRow.innerHTML = "";
    for(const f of FLAGS){
      const div = document.createElement("div");
      div.className = "flag" + (cpu.flags[f] ? " on" : "");
      div.textContent = `${f}=${cpu.flags[f] ? 1 : 0}`;
      flagsRow.appendChild(div);
    }

    cyclesEl.textContent = String(cpu.cycles);
  }

  function parseAddrInput(s){
    const n = parseNumber(s.trim());
    return (n === null) ? null : clamp16(n);
  }

  function refreshMemory(){
    let start = parseAddrInput(memStartEl.value);
    if(start === null) start = 0x0100;

    const rows = 16, cols = 16;
    let out = "";
    for(let r=0;r<rows;r++){
      const addr = (start + r*cols) & 0xFFFF;
      out += fmt(addr,4) + "  ";
      let ascii = "";
      for(let c=0;c<cols;c++){
        const b = mem[(addr+c) & 0xFFFF];
        out += b.toString(16).toUpperCase().padStart(2,"0") + " ";
        ascii += (b>=32 && b<=126) ? String.fromCharCode(b) : ".";
      }
      out += " |" + ascii + "|\n";
    }
    memDumpEl.textContent = out;
  }

  function activateTab(name){
    document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
    document.querySelectorAll(".panelBody").forEach(c => c.classList.toggle("active", c.id === "tab-" + name));
  }
  document.querySelectorAll(".tab").forEach(t => t.addEventListener("click", () => activateTab(t.dataset.tab)));

  // ---- Buttons / Events ----
  el("assembleBtn").addEventListener("click", () => {
    activateTab("output");
    if(assemble()){
      resetCPU(true);
      logLine("Ready to run/step.", "ok");
    }
  });

  el("runBtn").addEventListener("click", runProgram);

  el("stepBtn").addEventListener("click", () => {
    activateTab("output");
    if(program.length === 0){
      clearOutput();
      if(!assemble()) return;
      resetCPU(true);
      setStatus("Ready to step","run");
      logLine("Step mode ready. Press Step again.", "ok");
      return;
    }
    setStatus("Stepping…","run");
    const ok = stepOnce();
    if(!ok) setStatus("Stopped","ok");
  });

  el("resetBtn").addEventListener("click", () => {
    resetCPU(true);
    setStatus("Reset","ok");
    activateTab("output");
    logLine("Reset OK.", "ok");
  });

  baseSel.addEventListener("change", () => { updateUI(); refreshMemory(); });

  el("memRefresh").addEventListener("click", refreshMemory);

  exampleSel.addEventListener("change", (e) => {
    const v = e.target.value;
    if(!v) return;

    const EX = {
      case:
`ORG 100h
MOV SI, OFFSET STR
MOV CX, 2

L:
  MOV AL, BYTE PTR [SI]
  MOV AH, AL
  AND AH, 20h
  TEST AH, 20h
  JZ  C1
  JNZ C2

C1:
  ADD AL, 20h
  JMP OUT
C2:
  SUB AL, 20h
  JMP OUT

OUT:
  MOV BYTE PTR [SI], AL
  INC SI
  LOOP L
HLT

STR DB "ab"
`,
      ptr:
`ORG 200h
W1 DW 1234h
S1 DB "Hi", 0

MOV SI, OFFSET W1
MOV AX, WORD PTR [SI]
ADD AX, 1
MOV WORD PTR [SI], AX

MOV SI, OFFSET S1
MOV AL, BYTE PTR [SI]
HLT
`
    };

    codeEl.value = EX[v];
    localStorage.setItem(LS_CODE, codeEl.value);
    program = [];
    refreshGutter();
    clearOutput();
    setStatus("Loaded example","ok");
    e.target.value = "";
  });

  window.addEventListener("keydown", (e) => {
    if(e.ctrlKey && e.key === "Enter"){ e.preventDefault(); runProgram(); }
    if(e.key === "F10"){ e.preventDefault(); el("stepBtn").click(); }
    if(e.ctrlKey && (e.key === "r" || e.key === "R")){ e.preventDefault(); el("resetBtn").click(); }
  });

  function boot(){
    const saved = localStorage.getItem(LS_CODE);
    codeEl.value = saved ?? `ORG 100h
MOV SI, OFFSET STR
MOV CX, 2

L:
  MOV AL, BYTE PTR [SI]
  XOR AL, 20h
  MOV BYTE PTR [SI], AL
  INC SI
  LOOP L
HLT

STR DB "ab"
`;
    loadBreakpoints();
    refreshGutter();
    updateUI();
    refreshMemory();
    setStatus("Idle","idle");
    clearOutput();
    logLine("Tip: Assemble first to validate ORG/OFFSET/DB and labels.", "ok");
    activateTab("output");
  }

  boot();
})();
</script>
</body>
</html>
